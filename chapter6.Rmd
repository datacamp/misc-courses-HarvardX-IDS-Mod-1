---
title       : Indexing
description : R provides a powerful and convenient way of indexing vectors. We're going to learn some ways of doing that!
---
## Logical Vectors

```yaml
type: NormalExercise
key: 010704f684
lang: r
xp: 100
skills: 1
```
Here we will be using logical operators to create a logical vector.

`@instructions`
- Compute the per 100,000 murder rate for each state and store it in an object called `murder_rate`. 
- Then use the logical operators to create a logical vector, name it `low`, that tells us which entries of murder_rate are lower than 1.

`@hint`
The code for calculating the murder rate is: `murders$total/murders$population*100000`. 

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the murder rate per 100,000 for each state, in `murder_rate`
murder_rate <- murders$total / murders$population * 100000

# Store the `murder_rate < 1` in `low` 
```

`@solution`
```{r}
# Store the murder rate per 100,000 for each state, in `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Store the `murder_rate < 1` in `low` 
low <- murder_rate < 1
```

`@sct`
```{r}
test_error()
test_object("low", undefined_msg = "Define low!", incorrect_msg = "It should be murder rates less than 1.")
success_msg("Great job!")
```

---
## which

The function `which()` help us know directly, which values are low or high, etc. Let's use it in this question. 

```yaml
type: NormalExercise
key: 6830d22730
lang: r
xp: 100
skills: 1
```

`@instructions`
- Use the results from the previous exercise and the function `which` to determine the indices of `murder_rate` associated with values lower than 1.

`@hint`
`which` will return the TRUE logicals.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the murder rate per 100,000 for each state, in murder_rate
murder_rate <- murders$total/murders$population*100000

# Store the murder_rate < 1 in low 
low <- murder_rate < 1

# Get the indices of entries that are below 1

```

`@solution`
```{r}
# Store the murder rate per 100,000 for each state, in murder_rate
murder_rate <- murders$total/murders$population*100000

# Store the murder_rate < 1 in low 
low <- murder_rate < 1

# Get the indices of entries that are below 1
which(low)

```

`@sct`
```{r}
test_error()
test_output_contains("which(low)", incorrect_msg = "Make sure you use `which` on the correct logical vector!")
test_function("which", incorrect_msg = "Use the command from the instructions.")
success_msg("Awesome!")
```

---
## Ordering vectors

Note that if we want to know which entries of a vector are lower than some values we can use code like this:

```{r}
small <- murders$population < 1000000
murders$state[small]
```

The code above shows us the states with populations smaller than one million. 

```yaml
type: NormalExercise
key: d40747abe4
lang: r
xp: 100
skills: 1
```

`@instructions`
- Use the results from the previous exercise to report the names of the states with murder rates lower than 1, using the square brackets to retrieve the name of the states from the dataset. 

`@hint`


`@pre_exercise_code`
```{r}
library(dslabs)
data(dslabs)
```

`@sample_code`
```{r}
# Store the murder rate per 100,000 for each state, in murder_rate
murder_rate <- murders$total/murders$population*100000

# Store the murder_rate < 1 in low 
low <- murder_rate < 1

# Names of states with murder rates lower than 1

```

`@solution`
```{r}
# Store the murder rate per 100,000 for each state, in `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Store the `murder_rate < 1` in `low` 
low <- murder_rate < 1

# Names of states with murder rates lower than 1 
murders$state[low]

```

`@sct`
```{r}
test_error()
test_output_contains("murders$state[low]", incorrect_msg = "Follow code from example given!")
success_msg("Good job!")
```
---
## Filtering

```yaml
type: NormalExercise
key: 68370abd10
lang: r
xp: 100
skills: 1
```


`@instructions`
Now we will extend the code from the previous exercises to report the states in the Northeast with murder rates lower than 1.
- Define `low` as before.
- Use the `&` operator to create a new object `ind` that is true when `low` is true and the state is in the Northeast
- Use the brackets `[` and `ind` to show the state names that satisfy this condition


`@hint`
Use the previously defined logical vector `low` and the logical operator `&`. For states with less than 1 million it will be like this: 

```{r}
ind <- low & murders$population < 1000000

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the murder rate per 100,000 for each state, in `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Store the `murder_rate < 1` in `low` 
low <- murder_rate < 1

# Create a vector ind for states in the Northeast and with murder rates lower than 1. 

# Names of states in `ind` 

```

`@solution`
```{r}
# Store the murder rate per 100,000 for each state, in `murder_rate`
murder_rate <- murders$total/murders$population*100000

# Store the `murder_rate < 1` in `low` 
low <- murder_rate < 1

# States in the Northeast with murder rates lower than 1; store in 'ind'
ind <- low & murders$region=="Northeast"

# Names of states in `ind`
murders$state[ind]

```

`@sct`
```{r}
test_error()
test_object("murder_rate", undefined_msg = "Define murder rate", incorrect_msg = "Don't change anything, just run the code.")
test_object("low", undefined_msg = "Define low!", incorrect_msg = "Same as previous exercise.")
test_object("ind", undefined_msg = "Make sure to define ind first!", incorrect_msg = 'Use code ind <- low & murders$region=="Northeast".')
test_output_contains("murders$state[ind]", incorrect_msg = "Use [] to retrieve names.")
success_msg("Wasn't that good! Let's move to the next one.")
```
---
## Filtering continued

```yaml
type: NormalExercise
key: 11c3753c9c
lang: r
xp: 100
skills: 1
```


`@instructions`
In a previous exercise we computed the murder rate for each state and the average of these numbers.
- How many states are below the average?

`@hint`


`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the murder rate per 100,000 for each state, in murder_rate
murder_rate <- murders$total/murders$population*100000


# Compute average murder rate and store in avg using `mean` 


# How many states have murder rates below avg ? Check using sum 

```

`@solution`
```{r}
# Store the murder rate per 100,000 for each state, in murder_rate
murder_rate <- murders$total/murders$population*100000

# Compute average murder rate and store in avg using mean
avg <-mean(murder_rate)

# How many states are < avg ? Check using sum 
sum(murder_rate < avg)

```

`@sct`
```{r}
test_error()
test_object("murder_rate", undefined_msg = "Define the murder rate first!", incorrect_msg = "Same formula as before.")
test_object("avg", undefined_msg = "", incorrect_msg = "Compute the mean and store it here.")
test_function("sum", incorrect_msg = "Check the number of states below average murder rate.")
success_msg("Awesome!")
```
---
## Match

In this exercise we use the `match` function to identify the states with abbreviations AK, MI, and IA. 

```yaml
type: NormalExercise
key: 26843a3448
lang: r
xp: 100
skills: 1
```


`@instructions`
- Define a character vector with the abbreviations.
- Start by defining an index of the entries of `murders$abb` that match the three abbreviations.
- Use the `[` operator to extract the states.

`@hint`
Once you define `abbs <- c("AK", "MI", "IA")` you can then use match to figure out the indexes of where these appear with `ind <- match(abbs , murders$abb)`

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the 3 abbreviations in abbs in a vector (remember that they are character vectors and need quotes)

# Match the abbs to the murders$abb and store in ind

# Print state names from ind

```

`@solution`
```{r}
# Store the 3 abbreviations in abbs in a vector (remember that they are character vectors and need quotes)
abbs <- c("AK", "MI", "IA")

# Match the abbs to the murders$abb and store in `ind`
ind <- match(abbs , murders$abb)

# Print state names from `ind`
murders$state[ind]

```

`@sct`
```{r}
test_error()
test_object("abbs", undefined_msg = "Define abbs!", incorrect_msg = "Check the abbreviations stored.")
test_object("ind", undefined_msg = "Define ind!", incorrect_msg = "Make sure to use the match function ")
test_output_contains("murders$state[ind]", incorrect_msg = "Use square brackets.")
success_msg("Awesome!")
```
---
## %in%

If rather than an index we want a logical that tells us whether or not each element of a first vector is in we can use the function `%in%`.
For example: 

```{r}
x <- c(2, 3, 5)
y <- c(1, 2, 3, 4)
x%in%y
```
Gives us a two `TRUE` followed by a `FALSE` because 2 and 3 are in `y`.  

```yaml
type: NormalExercise
key: 8f682dcf90
lang: r
xp: 100
skills: 1
```


`@instructions`
Which of the following are actual abbreviations: MA, ME, MI, MO, MU?
- Define a character vector with the abbreviations MA, ME, MI, MO, MU.
- Use the `%` operator to create a logical vectors that is TRUE when the abbreviation is in `murders$abb`.

`@hint`
Look at what this does: 
```{r}
states <- c("New York", "Houston")
states%in%murders$state 
```

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the 5 abbreviations in `abbs`. (remember that they are character vectors)


# Use the %in% command to check if the entries of abbs are abbreviations in the the murders data frame

```

`@solution`
```{r}
# Store the 5 abbreviations in abbs. (remember that they are character vectors)
abbs <- c("MA", "ME", "MI", "MO", "MU") 

# Use the %in% command to check if the entries of abbs are abbreviations in the the murders data frame
abbs%in%murders$abb

```

`@sct`
```{r}
test_error()
test_object("abbs", undefined_msg = "Define abbs!", incorrect_msg = "Make sure to store the 5 abbreviations in abbs.")
test_output_contains("abbs%in%murders$abb", incorrect_msg = "Check the code. ")
success_msg("Great job!")
```
---
## Logical operator

```yaml
type: NormalExercise
key: bad79337d1
lang: r
xp: 100
skills: 1
```


`@instructions`
We are again working with the characters `abbs <- c("MA", "ME", "MI", "MO", "MU")`

- In a previous exercise we computed the index `abbs%in%murders$abb`. Use `which` and the `!` operator to get the index of the entries of `abbs` that are **not** abbreviations.
- Show the entries of `abbs` that are not actual abbreviations.

`@hint`
Use the code `ind <- which(!abbs%in%murders$abb)` to get the index. Then you can use the `[` to extract the correct values of `abs`.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store the 5 abbreviations in abbs. (remember that they are character vectors)
abbs <- c("MA", "ME", "MI", "MO", "MU") 

# Use the `which` command and `!` operator to find out which abbreviation are not actually part of the dataset and store in ind

# What are the entries of abbs that are not actual abbreviations

```

`@solution`
```{r}
# Store the 5 abbreviations in `abbs`. (remember that they are character vectors)
abbs <- c("MA", "ME", "MI", "MO", "MU") 

# Use the `which` command and `!` operator to find out which abbreviation is not actually part of the dataset and store in 'ind' 
ind <- which(!abbs%in%murders$abb)

# Names of abbs in `ind`
abbs[ind]

```

`@sct`
```{r}
test_error()
test_object("ind", undefined_msg = "Make sure you define ind first! ", incorrect_msg = "Use the which and ! codes." )
test_output_contains("abbs[ind]", incorrect_msg = "Have you used square brackets?")
success_msg("Awesome!")
```


---

## End of Assessment 6

```yaml
type: PlainMultipleChoiceExercise
lang: r
xp: 0
skills: 1
key: 693e3e8928
```
This is the end of the programming assignment for this section. 

You can now close this window to go back to the <a href='https://courses.edx.org/courses/course-v1:HarvardX+PH125.1x+2T2017/courseware/79c873ff79ea4680a67d98b169d2f2fc/8028545a22f34fd5b83aa5b16d2a02ce/?child=first'>course</a>.

If you want to continue the assessments without watching the videos, you can click on the arrow above to get the next exercise or hit Ctrl-K. WARNING: if you continue the assessments by clicking on the arrow to get the next exercise or by hitting Ctrl-K your assessments may NOT get scored.

`@instructions`
- Awesome
- Nope

`@hint`
- No hint necessary!

`@pre_exercise_code`
```{r}
# no pec
```

`@sct`
```{r}
msg1 = "Great! Now navigate back to the course on edX!"
msg2 = "Now navigate back to the course on edX!"
test_mc(correct = 1, feedback_msgs = c(msg1,msg2))
```


---
title       : Sorting
description : This chapter deals with getting more of an insight into the data we have, by helping us sort through it.
---
## sort

```yaml
type: NormalExercise
key: 8d2a5d166c
lang: r
xp: 100
skills: 1
```
When looking at a dataset, we may want to sort the data in an order that makes more sense for analysis. Let's learn to do this using the `murders` dataset as an example. 

`@instructions`
- Use the `$` operator to access the population size data and store it the object `pop`. 
- Then use the `sort` function to redefine `pop` so that it is sorted. 
- Finally use the `[` operator to report the smallest population size.

`@hint`
Make sure to use the `sort` function to redefine `pop` so that it is sorted.

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Access the `state` variable and store it in an object 
states <- murders$state 

# Sort the object alphabetically and redefine the object 
states <- sort(states) 

# Report the first alphabetical value  
states[1]

# Access population values from the dataset and store it in pop

# Sort the object and save it in the same object 

# Report the smallest population size 

```

`@solution`
```{r}
# Access the state variable and store it in an object 
states <- murders$state 

# Sort the object alphabetically and redefine the object 
states <- sort(states) 

# Report the first alphabetical value  
states[1]

# Access population values from the dataset and store it in pop
pop <- murders$population

# Sort the object and save it in the same object
pop <- sort(pop)

# Report the smallest population size 
pop[1]
```

`@sct`
```{r}
test_error()
test_object("pop", undefined_msg = "Make sure you define the object pop.", 
              incorrect_msg = "Check pop is properly defined and that you have redefined pop using the sort function.")
test_function("sort", index = 2,eval = TRUE,eq_condition = "equivalent", not_called_msg = "Make sure to call the sort function.",
              incorrect_msg = "Make sure to call it on the object `pop`.")
test_output_contains("pop[1]", incorrect_msg = "Use the square brackets, [, to report the smallest population value.")
success_msg("Good job! Now you know how to sort data in an ascending order.")
```

---
## order


The function `order()` returns the index vector needed to sort the vector. This implies that `sort(x)` and `x[order(x)]` give the same result.

This can be useful for finding row numbers with certain properties such as "the row for the state with the smallest population". 
Remember that when we extract a variable from a data frame the order of the resulting vector is the same as the order of the rows of the data frame. 
So for example, the entries of the vector `murders$state` are ordered in the same way as the states if you go down the rows of `murders`.

```yaml
type: NormalExercise
key: 9bf4a9a8ca
lang: r
xp: 100
skills: 1
```


`@instructions`
- Now instead of the smallest population size, let's find out the row number, in the data frame `murders`, of the state with the smallest population size.
- This time we need to replace the `order()` instead of `sort()`. 
- Remember that the entries in the vector `murders$population` follow the order of the rows of `murders`. 



`@hint`
Once you define `pop` with the population variable, get all the indexes using `o <- order(pop)`. The first index relates to the row with the smallest population.
`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Access population from the dataset and store it in pop

# Use the command order, to order pop and store in object o

# Find the index number of the entry with the smallest population size

```

`@solution`
```{r}
# Access population from the dataset and store it in pop
pop <- murders$population

# Use the command order, to order pop and store in object o
o <- order(pop)

# Find the index number of the entry with the smallest population size
o[1]

```

`@sct`
```{r}
test_error()
test_object("pop", undefined_msg = "Define pop first.", incorrect_msg = "Make sure you save population in pop.")
test_object("o", undefined_msg = "Make sure you define o first!", incorrect_msg = "Store pop using the order code in object o.")
test_output_contains("o[1]", incorrect_msg = "Use the command provided in the instructions.") 
test_function("order", index = 1,eval = TRUE,eq_condition = "equivalent", not_called_msg = "Make sure to call the order function.",
              incorrect_msg = "Make sure to call it on the object `pop`.")
success_msg("Great job!")
```

---
## New Codes 

We can actually perform the same operation as in the previous exercise using the function `which.min`. It basically tells us which is the minimum value. 

```yaml
type: NormalExercise
key: 69b30d5992
lang: r
xp: 100
skills: 1
```


`@instructions`
Write one line of code that gives the index of the lowest population entry.
Use the `which.min` command.

`@hint`
Use `which.min` directly. 

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Find the smallest value for variable total 
which.min(murders$total)

# Find the smallest value for population

```

`@solution`
```{r}
# Find the smallest value for variable total 
which.min(murders$total)

# Find the smallest value for population
which.min(murders$population)

```

`@sct`
```{r}
test_error()
test_output_contains("which.min(murders$population)", incorrect_msg = "Make sure you use $ to get the population data and simultaneously use which.min. And remember not to assign it to a variable.")
test_function("which.min",index=2)
test_student_typed("which.min(murders$population)",
                   fixed = TRUE,times = 1,not_typed_msg ="Use the $ simultaneously with the which.min function.")
success_msg("Great! You learned another function in R!")
```

---
## Using the output of order 

Now we know how small the smallest state is and we know which row represents it. However, which state is it? 

```yaml
type: NormalExercise
key: 3daf04cc14
lang: r
xp: 100
skills: 1
```


`@instructions`
- Find the index of the smallest state using `which.min(murders$population)`. 
- Define a variable `states` to hold the state names from the murders data frame.
- Combine these to find the state name for the smallest state.

`@hint`
Index the list of variables

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Define the variable i to be the index of the smallest state
i <- which.min(murders$population)

# Define variable states to hold the states

# Use the index you just defined to find the state with the smallest population
```

`@solution`
```{r}
# Define the variable i to be the index of the smallest state
i <- which.min(murders$population)

# Define variable states to hold the states
states <- murders$state

# Use the index you just defined to find the state with the smallest population
states[i]
```

`@sct`
```{r}
test_error()
test_function("which.min")
test_object("states", undefined_msg = "Define states first!", incorrect_msg = "Assign state values from dataset to states.")
test_output_contains("states[which.min(murders$population)]", incorrect_msg = "Copy code from instructions.")
success_msg("Awesome! Now we have the names of the states as well!")
```

---
## Ranks

You can create a data frame using the `data.frame` function. Here is a quick example:

```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
```

```yaml
type: NormalExercise
key: 655d8a25c3
lang: r
xp: 100
skills: 1
```


`@instructions`
- Define a variable `states` to be the state names from `murders`
- Use `rank(murders$population)` to determine the population size rank (from smallest to biggest) of each state. 
- Save these ranks in an object called `ranks`.
- Create a data frame with state names and their respective ranks. Call the data frame `my_df`. 


`@hint`

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Store temperatures in an object 
temp <- c(35, 88, 42, 84, 81, 30)

# Store city names in an object 
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")

# Create data frame with city names and temperature 
city_temps <- data.frame(name = city, temperature = temp)

# Define a variable states to be the state names 


# Define a variable ranks to determine the population size ranks 


# Create a data frame my_df with the state name and its rank

```

`@solution`
```{r}
# Store temperatures in an object 
temp <- c(35, 88, 42, 84, 81, 30)

# Store city names in an object 
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")

# Create data frame with city names and temperature 
city_temps <- data.frame(name = city, temperature = temp)

# Define a variable states to be the state names from the murders data frame
states <- murders$state

# Define a variable ranks to determine the population size ranks 
ranks <- rank(murders$population)

# Create a data frame my_df with the state name and its rank
my_df <- data.frame(states = states, ranks = ranks)
```

`@sct`
```{r}
test_error()
test_function("rank")
test_function("data.frame",index=2,incorrect_msg = "Don't delete the sample code.")
test_object("states", incorrect_msg = "Store the state names in states!")
test_object("ranks", undefined_msg = "Define ranks first!", incorrect_msg = "Define the rank of the population values!")
test_object("my_df", undefined_msg = "Define the data frame first.", incorrect_msg = "Use the command similar to the example.")
success_msg("That's awesome! You got this!")
```

---
## Data Frames, Ranks and Orders 

This exercise is somewhat more challenging. We are going to 
repeat the previous exercise but this time order `my_df` so that the states are ordered from least populous to most.

```yaml
type: NormalExercise
key: 62209cebec
lang: r
xp: 100
skills: 1
```


`@instructions`
- Create variables `states` and `ranks` to store the state names and ranks by population size respectively.
- Create an object `ind` that stores the indexes needed to order the population values, using the `order` command. For example we could define `o <- order(murders$population)`
- Create a data frame with both variables following the correct order. Use the bracket operator `[` to re-order each column in the data frame. For example, `states[o]` orders the abbreviations based by population size. 
- The columns of the data frame must be in the specific order: state, rate, rank.

`@hint`

When you define `my_df`, each column will be ordered using the `ind`. It will look something like this 

```{r}
my_df <- data.frame(name_1 = var_1[o], name_2 = var_2[o])
```

`@pre_exercise_code`
```{r}
library(dslabs)
data(murders)
```

`@sample_code`
```{r}
# Define a variable states to be the state names from the murders data frame


# Define a variable ranks to determine the population size ranks 


# Define a variable ind to store the indexes needed to order the population values


# Create a data frame my_df with the state name and its rank and ordered from least populous to most 

```

`@solution`
```{r}
# Define a variable states to be the state names from the murders data frame
states <- murders$state

# Define a variable ranks to determine the population size ranks 
ranks <- rank(murders$population)

# Define a variable ind to store the indexes needed to order the population values
ind <- order(murders$population)

# Create a data frame my_df with the state name and its rank and ordered from least populous to most 
my_df <- data.frame(states = states[ind], ranks = ranks[ind])

```

`@sct`
```{r}
test_error()
test_object("states", undefined_msg = "Define states first.", incorrect_msg = "")
test_object("ranks",undefined_msg = "Define ranks first.", incorrect_msg = "")
test_function("rank")
test_object("ind",undefined_msg = "Define ind first.", incorrect_msg = "Use the order command as well.")
test_function("order")
test_object("my_df", undefined_msg = "Define my_df first", incorrect_msg = "Check code.")
success_msg("Great job! See how well you're building on your knowledge of R!")
```

---
## NA

The `na_example` dataset represents a series of counts. It is included in the *dslabs* package. You can quickly examine the object using

```{r}
library(dslabs)
data(na_example)
str(na_example)
```

However, when we compute the average we obtain an `NA`. You can see this by typing 

```{r}
mean(na_example)
```

```yaml
type: NormalExercise
key: babfb93aab
lang: r
xp: 100
skills: 1
```


`@instructions`
- The `is.na` returns a logical vector that tells us which entries are `NA`. Assign the logical vector that is returned by `is.na(na_example)` to an object called `ind`.
- Determine how many `NA`s  `na_example` has, using the `sum` command.

`@hint`
If `x` is logical, `sum(x)` converts the `TRUE` to 1 and the `FALSE` to 0 before summing. So the sum is the number of `TRUE` entries.

`@pre_exercise_code`
```{r}
library(dslabs)
data(na_example)  
```

`@sample_code`
```{r}
# Using new dataset 
library(dslabs)
data(na_example)

# Checking the structure 
str(na_example)

# Find out the mean of the entire dataset 
mean(na_example)

# Use is.na to create a logical index ind that tells which entries are NA

# Determine how many NA ind has using the sum function

```

`@solution`
```{r}
# Using new dataset 
library(dslabs)
data(na_example)

# Checking the structure 
str(na_example)

# Find out the mean of the entire dataset 
mean(na_example)

# Use is.na to create an logical index ind that tells which entries are NA
ind <- is.na(na_example)

# Determine how many NA ind has using the sum function
sum(ind)

```

`@sct`
```{r}
test_error()
test_object("ind", undefined_msg = "Make sure to define ind first.", incorrect_msg = "Check instructions for the code.")
test_output_contains("sum(ind)", incorrect_msg = "Use the sum command to get the number of NAs.")
success_msg("Great job! Now let's move to one last thing in this chapter.")
```

---
## Removing NAs 

We previously computed the average of `na_example` using `mean(na_example)` and obtain `NA`. This is because the function `mean` returns `NA` if it encounters at least one `NA`.
A common operation is therefore removing the entries that are NA and after that perform operations on the rest. 


```yaml
type: NormalExercise
key: 0462684851
lang: r
xp: 100
skills: 1
```


`@instructions`

Write one line of code to compute the average, but only for the entries that are not NA making use of the `!` operator before `ind`. 


`@hint`
Remember the `!` operator. Note that `na_example[!ind]` returns the entries that are not NA. 

`@pre_exercise_code`
```{r}
library(dslabs)
data(na_example)
ind <- is.na(na_example)
```

`@sample_code`
```{r}
# Note what we can do with the ! operator
x <- c(1, 2, 3)
ind <- c(FALSE, TRUE, FALSE)
x[!ind]

# Create the ind vector
library(dslabs)
data(na_example)
ind <- is.na(na_example)

# We saw that this gives an NA
mean(na_example)

# Compute the average, for entries of na_example that are not NA 

```

`@solution`
```{r}
# Note what we can do with the ! operator
x <- c(1, 2, 3)
ind <- c(FALSE, TRUE, FALSE)
x[!ind]

# Create the ind vector
library(dslabs)
data(na_example)
ind <- is.na(na_example)

# We saw that this gives an NA
mean(na_example)

# Compute the average, for entries of na_example that are not NA 
mean(na_example[!ind])

```

`@sct`
```{r}
test_error()
test_output_contains("mean(na_example[!ind])", incorrect_msg = "Check your code from the instructions again.")
success_msg("Awesome! Now you're all set with vectors! Get practicing on your own!")
```

---

## End of Assessment 4

```yaml
type: PlainMultipleChoiceExercise
lang: r
xp: 0
skills: 1
key: be5cd4c525
```
This is the end of the programming assignment for this section. 

You can now close this window to go back to the <a href='https://courses.edx.org/courses/course-v1:HarvardX+PH125.1x+2T2017/courseware/2a638f36b59f4897b1bd6867ad58f63e/ca59fd4193f943f7b6c653a3b3bda450/?activate_block_id=block-v1%3AHarvardX%2BPH125.1x%2B2T2017%2Btype%40sequential%2Bblock%40ca59fd4193f943f7b6c653a3b3bda450'>course</a>.

If you want to continue the assessments without watching the videos, you can click on the arrow above to get the next exercise or hit Ctrl-K. WARNING: if you continue the assessments by clicking on the arrow to get the next exercise or by hitting Ctrl-K your assessments may NOT get scored.

`@instructions`
- Awesome
- Nope

`@hint`
- No hint necessary!

`@pre_exercise_code`
```{r}
# no pec
```

`@sct`
```{r}
msg1 = "Great! Now navigate back to the course on edX!"
msg2 = "Now navigate back to the course on edX!"
test_mc(correct = 1, feedback_msgs = c(msg1,msg2))
```


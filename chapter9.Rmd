---
title: Conceptos Básicos de Programación
description:Conceptos Básicos de Programación
---

## Condicionales

```yaml
type: MultipleChoiceExercise
key: 77691772c6
lang: r
xp: 50
skills:
  - 1
```

¿Qué devolverá esta expresión condicional?
Ejecútalo desde la consola.

```{r}
x <- c(1,2,-3,4)
if(all(x>0)){
    print("Todos positivos")
  } else{
     print("No todos positivos")
  }
```

`@posibles_respuestas`
- Todos positivos
- No todos positivos
- No disponible
- Ninguna de las anteriores

`@pista`
¿Los números almacenados en `x` son todos positivos? Si no, se evalúa `print` después de `else`.

`@Codigo_pre_ejercicio`
```{r}
# no pec
```

`@sct`
```{r}
msg1 = "¿Todas las entradas en `x` son positivas?"
msg2 = "¡Impresionante! Eso esta correcto."
msg3 = "En R puedes vectorizar relaciones lógicas como esta. No hay razón para tener NA"
msg4 = "Si `all(x>0)` es `TRUE` o `FALSE` se devuelve algo."
test_mc(correct = 2, feedback_msgs = c(msg1,msg2,msg3,msg4))
```

---

## Condicional continuado

```yaml
type: MultipleChoiceExercise
key: 78dfb810dd
lang: r
xp: 50
skills:
  - 1
```

¿Cuál de las siguientes expresiones es siempre `FALSE` cuando al menos una entrada de un vector lógico x es `TRUE`? Puede probar ejemplos en la consola R.

`@posibles_respuestas`
- all(x) 
- any(x) 
- any(!x) 
- all(!x)

`@pista`
Defina un vector lógico `x` como `c(TRUE, FALSE)` y `c(TRUE, TRUE)` y pruébelos.

`@Codigo_pre_ejercicio`
```{r}
# no pec
```

`@sct`
```{r}
msg1 = "Prueba `x <- c(TRUE, FALSE)` o `x <- c(TRUE,TRUE)`."
msg2 = "Prueba `x <- c(TRUE, TRUE)`"
msg3 = "Prueba `x <- c(TRUE, FALSE)"
msg4 = "¡Buen trabajo! Pasemos a la siguiente pregunta."
test_mc(correct = 4, feedback_msgs = c(msg1,msg2,msg3,msg4))
```

---

## ifelse

```yaml
type: NormalExercise
key: 04735d26b3
lang: r
xp: 100
skills:
  - 1
```

La función `nchar` te dice cuántos caracteres tiene un vector de caracteres. Por ejemplo:

```{r}
char_len <- nchar(murders$state)
head(char_len)
```
La función `ifelse` es útil porque convierte un vector de lógicos en otra cosa. Por ejemplo, algunos conjuntos de datos usan el número -999 para indicar NA. ¡Una mala práctica! Puede convertir el -999 en un vector a NA usando la siguiente llamada `ifelse`:

```{r}
x <- c(2, 3, -999, 1, 4, 5, -999, 3, 2, 9)
ifelse(x == -999, NA, x)
```
Si la entrada es -999, devuelve ; de lo contrario, devuelve la entrada.

`@instruciones`
Combinaremos una serie de funciones para este ejercicio.
- Use la función `ifelse` para escribir una línea de código que asigne al objeto `new_names` la abreviatura del estado cuando el nombre del estado tiene más de 8 caracteres y asigna el nombre del estado cuando el nombre no tiene más de 8 caracteres.

Por ejemplo, donde el vector original tiene Massachusetts (13 caracteres), el nuevo vector debe tener MA. Pero donde el vector original tiene Nueva York (8 caracteres), el nuevo vector también debería tener Nueva York.

`@pista`
Use una llamada a `nchar` como primer argumento de la función `ifelse` para calcular. Verifique si es mayor que 8. Luego use `murders$abb` y `murders$state` en el segundo y tercer argumento para devolver la abreviatura o el nombre del estado dependiendo de la cantidad de caracteres.

`@Codigo_pre_ejercicio`
```{r}
library(dslabs)
data(murders)
```

`@Codigo_de_muestra`
```{r}
# Asigne la abreviatura del estado cuando el nombre del estado tenga más de 8 caracteres

```

`@solucion`
```{r}
# Asigne la abreviatura del estado cuando el nombre del estado tenga más de 8 caracteres
new_names <- ifelse(nchar(murders$state)>8, murders$abb, murders$state)

```

`@sct`
```{r}
test_error()
test_function("ifelse")
test_object("new_names", undefined_msg = "¡Asegúrate de definir new_names!", incorrect_msg = "Tiene que ser una línea de código. Combine nchar y ifelse. Los objetos que se utilizan dentro de la función deben ser `murders$state` and `murders$abb`. También buscamos `nchar(murders$state)` estrictamente mayor que 8.")
success_msg("¡Guau! ¡Te estás convirtiendo en un profesional en esto!")

```

---

## Definiendo Funciones

```yaml
type: NormalExercise
key: 3d324d0749
lang: r
xp: 100
skills:
  - 1
```

Encontrará situaciones en las que la función que necesita aún no existe. R le permite escribir el suyo propio. Practiquemos una de esas situaciones, en la que primero debe definir la función que se utilizará. Las funciones que defina pueden tener varios argumentos, así como valores predeterminados.

Para definir funciones usamos `function`. Por ejemplo, la siguiente función suma 1 al número que recibe como argumento:

```{r}
my_func <- function(x){
    y <- x + 1
    y
}
```

Se devuelve el último valor de la función, en este caso el almacenado en `y`.

Si ejecuta el código anterior, R no muestra nada. Esto significa que definiste la función. Puedes probarlo así:

```{r}
my_func(5)
```

`@instrucciones`
Definiremos una función `sum_n` para este ejercicio.
- Cree una función `sum_n` que para cualquier valor dado, digamos `n`, cree el vector `1:n`, y luego calcule la suma de los números enteros de 1 a n.
- Utilice la función que acaba de definir para determinar la suma de los números enteros del 1 al 5000.

`@psita`

- Para que sea inclusivo, utilice {}.
- Puedes definir la función así:

```{r}
sum_n <- function(n){
    x <- 1:n
    sum(x)
}
```

`@Codigo_pre_ejercicio`
```{r}
# no pec 
```

`@Codigo_de_muestra`
```{r}

# Crear función llamada `sum_n`

# Usa la función para determinar la suma de enteros del 1 al 5000

```

`@solución`
```{r}

# Crear función llamada `sum_n`
sum_n <- function(n){
    x <- 1:n
    sum(x)
}


# Determinar la suma de enteros del 1 al 5000
sum_n(5000)

```

`@sct`
```{r}
test_error()
test_function("sum_n", incorrect_msg = "¡Necesitas verificar la suma de 5000 enteros!")
fun_def <- ex() %>% check_fun_def("sum_n")
fun_def %>% check_arguments()
fun_def %>% check_call(5000) %>% check_result() %>% check_equal()
fun_def %>% check_call(100) %>% check_result() %>% check_equal()
fun_def %>% check_call(1000) %>% check_result() %>% check_equal()

fun_def %>% check_body()
success_msg("¡Esto es increíble! Vayamos al siguiente ejercicio.")
```

---

## Defiendo funciones continuación...

```yaml
type: NormalExercise
key: ea64484119
lang: r
xp: 100
skills:
  - 1
```


Haremos otra función para este ejercicio. Definiremos una función `altman_plot` que toma dos argumentos `x` e `y` y traza la diferencia `y-x` en el eje y contra la suma `x+y` en el eje x.


Puede definir funciones con tantas variables como desee. Por ejemplo, aquí necesitamos al menos dos, `x` e `y`. La siguiente función traza valores transformados de registro:

```{r}
log_plot <- function(x, y){
    plot(log10(x), log10(y))
}
```

Esta función no devuelve nada. Simplemente hace una trama.

`@instrucciones`
Haremos otra función para este ejercicio.
- Cree una función `altman_plot` que tome dos argumentos `x` y `y` y grafique `y-x` (en el eje y) contra `x+y` (en el eje x).
- Nota: no use paréntesis alrededor de los argumentos en la función `plot` porque confundirá a R.
- 
`@pista`
El comando dentro de la función debería ser: `plot(x + y, y - x)`. Recuerda definir una función que uses

```{r}
altman_plot <- function(var_1, var_2){
    # code that uses var_1 and var_2
}
```

`@Codigo_pre_ejercicio`
```{r}
# no pec 
```

`@Código_de_muestra`
```{r}

# Crear `altman_plot`

```

`@solución`
```{r}
# Crear `altman_plot`
altman_plot <- function(x, y){
    plot(x + y, y - x)
}
```

`@sct`
```{r}
test_error()
test_function_definition("altman_plot",
                           body_test = {
                           	test_function("plot", incorrect_msg = "Asegúrate de llamar a `plot` dentro de tu función")
                            },
                         undefined_msg = "Asegúrese de definir `altman_plot`.",
                         incorrect_number_arguments_msg = "Asegúrate de que la función tome dos argumentos.")
test_object("altman_plot", incorrect_msg = "Asegúrate de usar `x` e `y` como argumentos y de trazar la diferencia `y-x` frente a la suma `x+y`. Escriba la suma como `x+y` no `y+x`. Además, para este ejercicio, queremos que use las llaves `{ }` como en el ejemplo. No use () alrededor de los argumentos en la función `plot` porque confundirá a R.") 
success_msg("¡Eso es genial! También puedes jugar con las variables y poner valores para x e y.")
```

---

## Ámbito léxico

```yaml
type: NormalExercise
key: f13e10ed3c
lang: r
xp: 100
skills:
  - 1
```

El ámbito léxico es una convención utilizada por muchos idiomas que determina cuándo un objeto está disponible por su nombre. Cuando ejecute el código a continuación, verá qué `x` está disponible en diferentes puntos del código.

```{r}
x <- 8
my_func <- function(y){
    x <- 9
    print(x)
    y + x
}
my_func(x)
print(x)
```
Tenga en cuenta que cuando definimos `x` como 9, esto está dentro de la función, pero es 8 después de ejecutar la función. La `x` cambió dentro de la función pero no fuera.

`@instrucciones`
Después de ejecutar el siguiente código, ¿cuál es el valor de `x`?
```{r}
x <- 3
my_func <- function(y){
    x <- 5
    y
    print(x)
}
my_func(x)
```


`@pista`
Ejecute el código y luego `print(x)`. Tendrás la respuesta.

`@Codigo_pre_ejercicio`
```{r}
x <- 3
```

`@Codigo_de_muestra`
```{r}

# Ejecutar este código
x <- 3
    my_func <- function(y){
    x <- 5
    y+5
}


# Imprime el valor de x
```
`@solución`
```{r}
# Mostrar valor de x
x
```

`@sct`
```{r}
test_error()
test_object("x", incorrect_msg = "¿Cómo se imprime el valor de x?")
success_msg("¡Buen trabajo!") 
```

---

## Bluckes For

```yaml
type: NormalExercise
key: efe45f5c56
lang: r
xp: 100
skills:
  - 1
```

En los próximos dos ejercicios, vamos a escribir un bucle for. En ese ciclo for vamos a llamar a una función. Comenzamos definiendo esa función aquí, en este ejercicio. Llamaremos al bucle for en el siguiente ejercicio.

`@instrucciones`
- Escribe una función `compute_s_n` que para cualquier $n$ determinado calcule la suma $S_n = 1^2 + 2^2 + 3^2 + \dots + n^2$.
- Reportar el valor de la suma cuando `n=10`.

`@pista`
La función se verá algo como esto:

```{r}
compute_s_n <- function(n){
    x <- 1:n
 ## suma el vector después de elevarlo al cuadrado
}
```
Luego lo evalúas en 10: `compute_s_n(10)`

`@Codigo_pre_ejercicio`

```{r}
# no pec 
```

`@Código_de_muestra`
```{r}

# Aquí hay un ejemplo de una función que suma números del 1 al n
example_func <- function(n){
    x <- 1:n
    sum(x)
}

# Aquí está la suma de los primeros 100 números
example_func(100)

# Escribe una función compute_s_n con el argumento n que para cualquier n calcula la suma de 1 + 2^2 + ...+ n^2

# Reportar el valor de la suma cuando n=10

```

`@solución`
```{r}
# Aquí hay una función que suma números del 1 al n
example_func <- function(n){
    x <- 1:n
    sum(x)
}

# Here is the sum of the first 100 numbers
example_func(100)

# Escribe una función compute_s_n con el argumento n que para cualquier n calcula la suma de 1 + 2^2 + ...+ n^2
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}

# Reportar el valor de la suma cuando n=10
compute_s_n(10)
```

`@sct`
```{r}
test_error()
test_function_result("compute_s_n", incorrect_msg ="Asegúrese de que su función esté produciendo la salida correcta.")
test_output_contains("compute_s_n(10)", incorrect_msg = "Asegúrese de que su función esté produciendo la salida correcta.")
test_student_typed("compute_s_n(10)", not_typed_msg = "Asegúrate de evaluar la función en 10 en la última línea.")
fun_def <- ex() %>% check_fun_def("compute_s_n")
fun_def %>% check_arguments()
fun_def %>% check_call(10) %>% check_result() %>% check_equal()
fun_def %>% check_call(100) %>% check_result() %>% check_equal()
fun_def %>% check_call(1000) %>% check_result() %>% check_equal()
fun_def %>% check_body()
success_msg("¡Eso es genial! ¡Te estás volviendo tan bueno en esto!")
```

---

## Bucles For continuación...

```yaml
type: NormalExercise
key: a9bf58a40c
lang: r
xp: 100
skills:
  - 1
```
Ahora vamos a calcular la suma de los cuadrados de varios valores de $n$. Usaremos un bucle for para esto. Aquí hay un ejemplo de un bucle for:

```{r}
results <- vector("numeric", 10)
n <- 10
for(i in 1:n){
    x <- 1:i
    results[i] <- sum(x)
}
```

Tenga en cuenta que comenzamos con una llamada a `vector` que construye un vector vacío que llenaremos mientras se ejecuta el ciclo.

`@instrucciones`
- Defina un vector numérico vacío `s_n` de tamaño 25 usando `s_n <- vector("numeric", 25)`.
- Calcula la suma cuando n es igual a cada número entero del 1 al 25 usando la función que definimos en el ejercicio anterior: `compute_s_n`
- Guarda los resultados en `s_n`

`@pista`
La línea de código dentro de la función será `s_n[i] <- compute_s_n(i)`.

`@Codigo_pre_ejercicio`
```{r}
# no pec 
```

`@Código_de_muestra`
```{r}
# Definir una función y guardarla en `compute_s_n`
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}

# Definir una función y guardarla en `compute_s_n`
s_n <- vector("numeric", 25)


# escribir un ciclo for para almacenar los resultados en s_n
```

`@solución`
```{r}

# Definir una función y guardarla en `compute_s_n`
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}

# Crear un vector para almacenar resultados
s_n <- vector("numeric", 25)


# Asigna valores a `n` y `s_n`
for(i in 1:25){
  s_n[i] <- compute_s_n(i)
}
```

`@sct`
```{r}
test_error()
test_object("compute_s_n", undefined_msg = "Asegúrese de definir compute_s_n primero.", incorrect_msg = "¿Estás asignando los valores correctos a x?")
test_object("s_n", incorrect_msg = "
Está obteniendo los valores incorrectos. Comprueba que estás llamando a la función correctamente.")
test_function("vector")
fun_def <- ex() %>% check_fun_def("compute_s_n")
fun_def %>% check_arguments()
fun_def %>% check_call(10) %>% check_result() %>% check_equal()
fun_def %>% check_call(100) %>% check_result() %>% check_equal()
fun_def %>% check_call(1000) %>% check_result() %>% check_equal()
fun_def %>% check_body()
for_loop <- ex() %>% check_for()
# verificar condición ("i en 1:5" en la solución)
# tenga en cuenta que check_code podría ser demasiado estricto, ya que alguien podría
# crear una variable, p. a <- 1:5, y dale eso al ciclo for
for_loop %>% check_cond() 
#%>% check_code("in n", fixed = TRUE)
success_msg("¡Esto es genial! Ahora conoce los conceptos básicos de bucles for en R.")
```

---

## Comprobando nuestras matemáticas

```yaml
type: NormalExercise
key: 4e649b5400
lang: r
xp: 100
skills:
  - 1
```

Si hacemos los cálculos, podemos demostrar que

$$S_n = 1^2 + 2^2 + 3^2 + \dots + n^2 = n(n+1)(2n+1)/6 $$

Ya hemos calculado los valores de $S_n$ de 1 a 25 usando un bucle for.

Si la fórmula es correcta, una gráfica de $S_n$ frente a $n$ debería verse cúbica.

Hagamos esta trama.
`@instrucciones`
- Definir `n <- 1:25`. Note que con esto podemos usar `for(i in n)`
- Use un bucle for para guardar las sumas en un vector `s_n <- vector("numeric", 25)`
- Traza `s_n` (en el eje y) contra `n` (en el eje x).

`@pista`

En el código de la trama, `n` es el eje x y `s_n` es el eje y.
`@Codigo_pre_ejercicio`
```{r}
# no pec 
```

`@Codigo_de_muestra`
```{r}

# Defina la función
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}

# Defina el vector de n
n <- 1:25

# Defina el vector para almacenar datos
s_n <- vector("numeric", 25)
for(i in n){
  s_n[i] <- compute_s_n(i)
}

# Crea la trama

```

`@solución`
```{r}

# Definir la función
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}


# Defina el vector de n
n <- 1:25

# Defina el vector para almacenar datos
s_n <- vector("numeric", 25)
for(i in n){
  s_n[i] <- compute_s_n(i)
}

# Crea la trama
plot(n, s_n)
```

`@sct`
```{r}
test_error()
test_function("plot",args=c("x","y"), incorrect_msg = "¿Trazó correctamente los ejes x e y?")
success_msg("¡Impresionante! ¡Vamos al último ejercicio de este capítulo!")
```

---

## Comprobando nuestras matemáticas continuación

```yaml
type: NormalExercise
key: 33ed29e3c1
lang: r
xp: 100
skills:
  - 1
```
Ahora vamos a comprobar si obtenemos exactamente la misma respuesta.

`@instrucciones`
- Confirme que `s_n` y $n(n+1)(2n+1)/6$ son iguales usando el comando `identical`.

`@pista`
`s_n` es un vector. Porque `n` es un vector `n*(n+1)*(2*n+1)/6` es un vector. Puedes comparar dos vectores `x` e `y` con `identical(x, y)`.

`@Codigo_pre_ejercicio`
```{r}
# no pec
```

`@Codigo_de_muestra`
```{r}
# Definir la función
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}

# Definir el vector de n
n <- 1:25

# Definir el vector para almacenar datos
s_n <- vector("numeric", 25)
for(i in n){
  s_n[i] <- compute_s_n(i)
}

# Verifique que s_n sea idéntico a la fórmula dada en las instrucciones.
```

`@solución`
```{r}

# Definir la función
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}

# Definir el vector de n
n <- 1:25

# Definir el vector para almacenar datos
s_n <- vector("numeric", 25)
for(i in n){
  s_n[i] <- compute_s_n(i)
}


# Verifique que s_n sea idéntico a la fórmula dada en las instrucciones.
idéntico(s_n, n*(n+1)*(2*n+1)/6)
```

`@sct`
```{r}
test_error()
test_function("identical")
test_output_contains("identical(s_n, n*(n+1)*(2*n+1)/6)", incorrect_msg = "¡Asegúrate de revisar tu fórmula!")
success_msg("¡Esto es genial! Hemos terminado con este módulo. ¡Es hora de pasar a cosas más grandes!")
```

---

## Fin de la Evaluación 9

```yaml
type: PureMultipleChoiceExercise
key: 226fb8de61
lang: r
xp: 50
skills:
  - 1
```

Este es el final de la asignación de programación para esta sección. NO haga clic para acceder a evaluaciones adicionales desde esta página. Por favor, RESPONDA la pregunta en esta página. Si hace clic, es posible que NO se registren sus puntajes.

Haga clic en "Impresionante" para obtener los "puntos" de esta pregunta y luego regrese al curso en edX.

Ahora puede cerrar esta ventana para volver al <a href='https://www.edx.org/course/data-science-r-basics-2'>curso</a>.

`@pista`
- ¡No es necesario dar pistas!

`@posibles_respuestas`
- [Impresionante]
- No

`@comentarios`
- ¡Gran! ¡Ahora vuelve al curso en edX!
- ¡Ahora vuelve al curso en edX!
